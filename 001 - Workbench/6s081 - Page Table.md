#### Pre-questions

- What is PTE?
	- a 56-bit value mapping vaddr(index) to paddr and contains control bits(Flags)
	- 44bit + 10bit(Flags)
	- 2^27 PTEs available,
	- vaddr is just a value you should not needing care of
- Where are the page table saved?
	- in physical memory
	- kernel to handle PTE not present that paging hardware raised #qa
- Bytes vs Bits?
	- Although the address we used in virtual address is united by Bit, each Bit definitely refer to 1-Byte in the physical memory that the way it constructed.
- What is page?
	- you have noticed that distinct PPN distribute to each PTE
	- a page is a **single** entry of PTE
	- it consist 12-bit offset retrieved from VA and point to 2^12 bytes of PA
- What is page directory?
	- It consist 512 PTEs confirms to 3-levels structure. 
	- A **intermediate** PTE required 4096-byte to store 512 entries of PTEs, a page directory
		- 54bit * 512 / 8 = 3456-byte - **consist PPNs and Flags**
	- **AKA page table** (split with whitespace)
	- differentiate PPN and PTE
- Three layers of table?
	- top(top 9-bit)-middle-final
	- memory-efficient
		- if the application memory using is unknown to you, you do not have to allocate a bunch of memory for it.
		- keep VA sequence and continual for specific app.
- What is TLB (Translation Look-aside Buffer) ?
	- To avoid the cost of loading PTEs from physical memory, a RISC-V CPU caches page table entries in a Translation Look-aside Buffer (TLB).
	- So you need to flush it when CPU changing.
- CPU is using page table by reading `satp` reg. Each has one.
	- pagetable is a private address space for each CPU? #q
- Typically kernel mapping all physical memory to it's pagetable
	- give each process a whole page-table with from 0 through MAXVA would not interfere to ANY OTHER VAs, since the instructions is use `satp` to locate physical memory. You just ensure each page-table has been correctly mapped.  ^e34ac5
- one page table per process
	- 512 entries of PTE? #q
	- plus a page for kernel's address space
- Instructions use only virtual address.

- kernel direct mapping
	- fork #q
	- exceptions
		- trampoline
		- kernel stack page
			- guard page
				- protect from kstack overflow and overwrite
	- combine using VA and Direct Mapping to avoid guard page interfere physical memory

- `walk` find PTE for VA
	- if PTE not valid, it hasn't been allocated
	- if `alloc` arg is set, walk will `alloc` it when it's invalid
- `mappages` install PTEs for new mapping
- `copyin` and `copyout` copy user VA to system call args

- `main` -> `kvminit` create kernel page table by `kvmmake`
	- `kvmmake` -> allocate root pagetable
- -> `kvmmap` -> install the trans that kernel needs
	- kernel instructions and data
	- **with physical memory up to `PHYSTOP`**
	- actual devices
- -> `proc_mapstacks` allocates kernel stack for each process
	- `kvmmap` map stacks VA generated by `KSTACK`
	- stack-guard pages
- -> `kvminithart` install kernel page table (set `satp`)

- `kvmmap` -> `mappages`
	- `walk` get PTE
	- allocate PPN and Flags

- The price of 3-levels layer? #q
	- three times calling (`walk`) recursively to find the actual PPE
	- 512 * 512 extra PTE items to storage new level identity

- invalid TLB during CPU change to avoid illegal cross-process accessing
	- perform `sfence.vma` before switching to ensure all the preceding changes have been successfully done

- allocate physical memory for page tables, user memory, kernel stacks, pipe buffers #q
	- physical memory is protected by spin lock, and use linked list to track
	- `acquire`
	- `release`
	- a PTE is only refer to a physical address aligned on 4096-byte boundary (2^12)
	- treat address as integer to perform arithmetic on them
		- `freerange`
		- `run`

- `kfree` setting every byte in physical memory to value 1
	- cause such code to break faster? #q

- How to protect user program?
	- do not add `PTE_W` for program **text** address
	- do not add `PTE_X` for program **data** address
	- what actually is improved? #q

- To prevent form stackoverflow, add a guard page below the stack and clear the `PTE_U` flag.
- Give each process a whole pagetable.
	- [[6s081 - Page Table#^e34ac5|for more, see here]]
- Note that pagetable contains the ONLY record of where the physical memory goes.
	- Scan whole pagetable before free it, to prevent any memory leaks.

- `exec()` will create a pagetable for process with `proc_pagetable`